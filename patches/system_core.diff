diff --git a/include/cutils/klog.h b/include/cutils/klog.h
index d5ae6d7..ebe9554 100644
--- a/include/cutils/klog.h
+++ b/include/cutils/klog.h
@@ -44,6 +44,6 @@ __END_DECLS
 #define KLOG_INFO(tag,x...)    klog_write(KLOG_INFO_LEVEL, "<6>" tag ": " x)
 #define KLOG_DEBUG(tag,x...)   klog_write(KLOG_DEBUG_LEVEL, "<7>" tag ": " x)
 
-#define KLOG_DEFAULT_LEVEL  3  /* messages <= this level are logged */
+#define KLOG_DEFAULT_LEVEL  7  /* messages <= this level are logged */
 
 #endif
diff --git a/include/system/audio.h b/include/system/audio.h
index 093da96..d6f8805 100644
--- a/include/system/audio.h
+++ b/include/system/audio.h
@@ -68,6 +68,9 @@ typedef enum {
                                          * Plays over speaker only, silent on other devices.
                                          */
     AUDIO_STREAM_ACCESSIBILITY    = 10, /* For accessibility talk back prompts */
+#ifdef SPRD_HARDWARE
+    AUDIO_STREAM_FM               = 10,
+#endif
     AUDIO_STREAM_REROUTING        = 11, /* For dynamic policy output mixes */
     AUDIO_STREAM_PATCH            = 12, /* For internal audio flinger tracks. Fixed volume */
     AUDIO_STREAM_PUBLIC_CNT       = AUDIO_STREAM_TTS + 1,
@@ -150,6 +153,9 @@ typedef enum {
                                           /* An example of remote presentation is Wifi Display */
                                           /*  where a dongle attached to a TV can be used to   */
                                           /*  play the mix captured by this audio source.      */
+#ifdef SPRD_HARDWARE
+    AUDIO_SOURCE_RECORD_NO_AUDIO     = 9, /* SPRD: add one audioSource type for slow motion */
+#endif
 #ifdef QCOM_HARDWARE
     AUDIO_SOURCE_FM_RX               = 10,
     AUDIO_SOURCE_FM_RX_A2DP          = 11,
@@ -684,6 +690,10 @@ enum {
     AUDIO_DEVICE_OUT_FM_TX                     = 0x1000000,
     AUDIO_DEVICE_OUT_PROXY                     = 0x2000000,
 #endif
+#if defined(SPRD_HARDWARE)
+    AUDIO_DEVICE_OUT_FM_HEADSET                = 0x1000000,
+    AUDIO_DEVICE_OUT_FM_SPEAKER                = 0x2000000,
+#endif
     AUDIO_DEVICE_OUT_DEFAULT                   = AUDIO_DEVICE_BIT_DEFAULT,
     AUDIO_DEVICE_OUT_ALL      = (AUDIO_DEVICE_OUT_EARPIECE |
                                  AUDIO_DEVICE_OUT_SPEAKER |
@@ -712,6 +722,10 @@ enum {
                                  AUDIO_DEVICE_OUT_FM_TX |
                                  AUDIO_DEVICE_OUT_PROXY |
 #endif
+#if defined(SPRD_HARDWARE)
+                                 AUDIO_DEVICE_OUT_FM_HEADSET |
+                                 AUDIO_DEVICE_OUT_FM_SPEAKER |
+#endif
                                  AUDIO_DEVICE_OUT_DEFAULT),
     AUDIO_DEVICE_OUT_ALL_A2DP = (AUDIO_DEVICE_OUT_BLUETOOTH_A2DP |
                                  AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
@@ -721,6 +735,10 @@ enum {
                                  AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT),
     AUDIO_DEVICE_OUT_ALL_USB  = (AUDIO_DEVICE_OUT_USB_ACCESSORY |
                                  AUDIO_DEVICE_OUT_USB_DEVICE),
+#if defined(SPRD_HARDWARE)
+    AUDIO_DEVICE_OUT_ALL_FM   = (AUDIO_DEVICE_OUT_FM_HEADSET |
+                                 AUDIO_DEVICE_OUT_FM_SPEAKER),
+#endif
 
     /* input devices */
     AUDIO_DEVICE_IN_COMMUNICATION         = AUDIO_DEVICE_BIT_IN | 0x1,
diff --git a/include/system/graphics.h b/include/system/graphics.h
index b207ee8..c12ad6f 100644
--- a/include/system/graphics.h
+++ b/include/system/graphics.h
@@ -318,7 +318,21 @@ enum {
     /* Legacy formats (deprecated), used by ImageFormat.java */
     HAL_PIXEL_FORMAT_YCbCr_422_SP       = 0x10, // NV16
     HAL_PIXEL_FORMAT_YCrCb_420_SP       = 0x11, // NV21
+#ifdef SPRD_HARDWARE
+    HAL_PIXEL_FORMAT_YCbCr_422_P        = 0x12,
+    HAL_PIXEL_FORMAT_YCbCr_420_P        = 0x13,
+#endif
     HAL_PIXEL_FORMAT_YCbCr_422_I        = 0x14, // YUY2
+#ifdef SPRD_HARDWARE
+    HAL_PIXEL_FORMAT_YCbCr_420_I        = 0x15,
+    HAL_PIXEL_FORMAT_CbYCrY_422_I       = 0x16,
+    HAL_PIXEL_FORMAT_CbYCrY_420_I       = 0x17,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED = 0x18,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP       = 0x19,
+    HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED = 0x1A,
+    HAL_PIXEL_FORMAT_YCrCb_422_SP       = 0x1B,
+    HAL_PIXEL_FORMAT_YCrCb_420_P        = 0x1C,
+#endif
 };
 
 /*
diff --git a/init/Android.mk b/init/Android.mk
index c6863bf..eb9b410 100755
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -68,6 +68,8 @@ LOCAL_STATIC_LIBRARIES := \
 	libz
 
 LOCAL_ADDITIONAL_DEPENDENCIES += $(LOCAL_PATH)/Android.mk
+LOCAL_C_INCLUDES += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include/mtd
+
 ifneq ($(strip $(TARGET_PLATFORM_DEVICE_BASE)),)
 LOCAL_CFLAGS += -D_PLATFORM_BASE="\"$(TARGET_PLATFORM_DEVICE_BASE)\""
 endif
diff --git a/init/builtins.c b/init/builtins.c
index d4b3f99..d206347 100644
--- a/init/builtins.c
+++ b/init/builtins.c
@@ -48,6 +48,8 @@
 #include "log.h"
 
 #include <private/android_filesystem_config.h>
+#include <sys/ioctl.h>
+#include "ubi-user.h"
 
 #if BOOTCHART
 #include "bootchart.h"
@@ -421,6 +423,34 @@ int do_mkdir(int nargs, char **args)
     return 0;
 }
 
+#define UBI_CTRL_DEV "/dev/ubi_ctrl"
+int do_ubiAttach(int nargs, char **args)
+{
+    struct ubi_attach_req req;
+    int fd;
+    int ret;
+
+    ERROR("do_ubiAttach %s %s\n",args[1],args[2]);
+
+    memset(&req, 0, sizeof(struct ubi_attach_req));
+    req.ubi_num =(typeof(req.ubi_num))atoi(args[1]);
+    if(-1 == req.ubi_num){
+        req.ubi_num = UBI_DEV_NUM_AUTO;
+    }
+    req.mtd_num = (typeof(req.mtd_num))mtd_name_to_number( args[2]);
+
+    fd = open(UBI_CTRL_DEV, O_RDONLY);
+    if(-1 == fd){
+        return -1;
+    }
+    ret = ioctl(fd, UBI_IOCATT, &req);
+    close(fd);
+    if(-1 == ret){
+        return -1;
+    }
+    return 0;
+}
+
 static struct {
     const char *name;
     unsigned flag;
@@ -561,7 +591,6 @@ static int wipe_data_via_recovery()
     while (1) { pause(); }  // never reached
 }
 
-
 /*
  * This function might request a reboot, in which case it will
  * not return.
@@ -1033,3 +1062,11 @@ int do_umount(int nargs, char **args) {
     return umount(args[1]);
 }
 
+int do_pipe(int nargs, char **args) {
+    mode_t mode = get_mode(args[1]);
+    if (mkfifo(args[2], mode) < 0) {
+	ERROR("peter do pipe error haha\n");
+        return -errno;
+    }
+    return 0;
+}
diff --git a/init/init_parser.c b/init/init_parser.c
index eec9090..f2398e6 100644
--- a/init/init_parser.c
+++ b/init/init_parser.c
@@ -135,6 +135,7 @@ static int lookup_keyword(const char *s)
         break;
     case 'p':
         if (!strcmp(s, "owerctl")) return K_powerctl;
+        if (!strcmp(s, "ipe")) return K_pipe;   //sprd add for loopback test
     case 'r':
         if (!strcmp(s, "estart")) return K_restart;
         if (!strcmp(s, "estorecon")) return K_restorecon;
@@ -165,7 +166,8 @@ static int lookup_keyword(const char *s)
         break;
     case 'u':
         if (!strcmp(s, "ser")) return K_user;
-	   if (!strcmp(s, "mount")) return K_umount;
+        if (!strcmp(s, "mount")) return K_umount;
+        if (!strcmp(s, "biattach")) return K_ubiattach;
         break;
     case 'w':
         if (!strcmp(s, "rite")) return K_write;
diff --git a/init/keywords.h b/init/keywords.h
index 224a505..cb7a427 100644
--- a/init/keywords.h
+++ b/init/keywords.h
@@ -14,6 +14,7 @@ int do_hostname(int nargs, char **args);
 int do_ifup(int nargs, char **args);
 int do_insmod(int nargs, char **args);
 int do_mkdir(int nargs, char **args);
+int do_ubiAttach(int nargs, char **args);
 int do_mount_all(int nargs, char **args);
 int do_mount(int nargs, char **args);
 int do_powerctl(int nargs, char **args);
@@ -42,6 +43,7 @@ int do_log(int nargs, char **args);
 int do_loglevel(int nargs, char **args);
 int do_load_persist_props(int nargs, char **args);
 int do_load_all_props(int nargs, char **args);
+int do_pipe(int nargs, char **args);
 int do_wait(int nargs, char **args);
 int do_umount(int nargs, char **args);
 #define __MAKE_KEYWORD_ENUM__
@@ -71,6 +73,7 @@ enum {
     KEYWORD(import,      SECTION, 1, 0)
     KEYWORD(keycodes,    OPTION,  0, 0)
     KEYWORD(mkdir,       COMMAND, 1, do_mkdir)
+    KEYWORD(ubiattach,   COMMAND, 2, do_ubiAttach)
     KEYWORD(mount_all,   COMMAND, 1, do_mount_all)
     KEYWORD(mount,       COMMAND, 3, do_mount)
     KEYWORD(on,          SECTION, 0, 0)
@@ -109,6 +112,7 @@ enum {
     KEYWORD(loglevel,    COMMAND, 1, do_loglevel)
     KEYWORD(load_persist_props,    COMMAND, 0, do_load_persist_props)
     KEYWORD(load_all_props,        COMMAND, 0, do_load_all_props)
+    KEYWORD(pipe,        COMMAND, 2, do_pipe)
     KEYWORD(ioprio,      OPTION,  0, 0)
     KEYWORD(umount,		COMMAND, 1, do_umount)
 #ifdef __MAKE_KEYWORD_ENUM__
diff --git a/init/property_service.c b/init/property_service.c
index 322f4d8..588c5aa 100644
--- a/init/property_service.c
+++ b/init/property_service.c
@@ -70,6 +70,7 @@ struct {
     { "net.lte",          AID_RADIO,    0 },
     { "net.cdma",         AID_RADIO,    0 },
     { "ril.",             AID_RADIO,    0 },
+    { "ril.",             AID_SYSTEM,   0 },
     { "gsm.",             AID_RADIO,    0 },
     { "persist.radio",    AID_RADIO,    0 },
     { "net.dns",          AID_RADIO,    0 },
@@ -93,9 +94,11 @@ struct {
     { "service.adb.tcp.port", AID_SHELL,    0 },
     { "persist.logd.size",AID_SYSTEM,   0 },
     { "persist.sys.",     AID_SYSTEM,   0 },
+    { "persist.msms.",    AID_RADIO,   0 },//SPRD: add for dsds
     { "persist.service.", AID_SYSTEM,   0 },
     { "persist.security.", AID_SYSTEM,   0 },
     { "persist.gps.",      AID_GPS,      0 },
+    { "media.", AID_MEDIA,   0 },
     { "persist.service.bdroid.", AID_BLUETOOTH,   0 },
     { "selinux."         , AID_SYSTEM,   0 },
     { "wc_transport.",     AID_BLUETOOTH,   AID_SYSTEM },
@@ -394,8 +397,8 @@ void handle_property_set_fd()
             if (check_perms(msg.name, source_ctx)) {
                 property_set((char*) msg.name, (char*) msg.value);
             } else {
-                ERROR("sys_prop: permission denied uid:%d  name:%s\n",
-                      cr.uid, msg.name);
+                ERROR("sys_prop: permission denied pid:%d uid:%d name:%s\n",
+                      cr.pid, cr.uid, msg.name);
             }
 
             // Note: bionic's property client code assumes that the
diff --git a/init/ubi-user.h b/init/ubi-user.h
new file mode 100644
index 0000000..53cae1e
--- /dev/null
+++ b/init/ubi-user.h
@@ -0,0 +1,420 @@
+/*
+ * Copyright © International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Author: Artem Bityutskiy (Битюцкий Артём)
+ */
+
+#ifndef __UBI_USER_H__
+#define __UBI_USER_H__
+
+#include <linux/types.h>
+
+/*
+ * UBI device creation (the same as MTD device attachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI
+ * control device. The caller has to properly fill and pass
+ * &struct ubi_attach_req object - UBI will attach the MTD device specified in
+ * the request and return the newly created UBI device number as the ioctl
+ * return value.
+ *
+ * UBI device deletion (the same as MTD device detachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI
+ * control device.
+ *
+ * UBI volume creation
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * UBI volumes are created via the %UBI_IOCMKVOL ioctl command of UBI character
+ * device. A &struct ubi_mkvol_req object has to be properly filled and a
+ * pointer to it has to be passed to the ioctl.
+ *
+ * UBI volume deletion
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * To delete a volume, the %UBI_IOCRMVOL ioctl command of the UBI character
+ * device should be used. A pointer to the 32-bit volume ID hast to be passed
+ * to the ioctl.
+ *
+ * UBI volume re-size
+ * ~~~~~~~~~~~~~~~~~~
+ *
+ * To re-size a volume, the %UBI_IOCRSVOL ioctl command of the UBI character
+ * device should be used. A &struct ubi_rsvol_req object has to be properly
+ * filled and a pointer to it has to be passed to the ioctl.
+ *
+ * UBI volumes re-name
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * To re-name several volumes atomically at one go, the %UBI_IOCRNVOL command
+ * of the UBI character device should be used. A &struct ubi_rnvol_req object
+ * has to be properly filled and a pointer to it has to be passed to the ioctl.
+ *
+ * UBI volume update
+ * ~~~~~~~~~~~~~~~~~
+ *
+ * Volume update should be done via the %UBI_IOCVOLUP ioctl command of the
+ * corresponding UBI volume character device. A pointer to a 64-bit update
+ * size should be passed to the ioctl. After this, UBI expects user to write
+ * this number of bytes to the volume character device. The update is finished
+ * when the claimed number of bytes is passed. So, the volume update sequence
+ * is something like:
+ *
+ * fd = open("/dev/my_volume");
+ * ioctl(fd, UBI_IOCVOLUP, &image_size);
+ * write(fd, buf, image_size);
+ * close(fd);
+ *
+ * Logical eraseblock erase
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To erase a logical eraseblock, the %UBI_IOCEBER ioctl command of the
+ * corresponding UBI volume character device should be used. This command
+ * unmaps the requested logical eraseblock, makes sure the corresponding
+ * physical eraseblock is successfully erased, and returns.
+ *
+ * Atomic logical eraseblock change
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * Atomic logical eraseblock change operation is called using the %UBI_IOCEBCH
+ * ioctl command of the corresponding UBI volume character device. A pointer to
+ * a &struct ubi_leb_change_req object has to be passed to the ioctl. Then the
+ * user is expected to write the requested amount of bytes (similarly to what
+ * should be done in case of the "volume update" ioctl).
+ *
+ * Logical eraseblock map
+ * ~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To map a logical eraseblock to a physical eraseblock, the %UBI_IOCEBMAP
+ * ioctl command should be used. A pointer to a &struct ubi_map_req object is
+ * expected to be passed. The ioctl maps the requested logical eraseblock to
+ * a physical eraseblock and returns.  Only non-mapped logical eraseblocks can
+ * be mapped. If the logical eraseblock specified in the request is already
+ * mapped to a physical eraseblock, the ioctl fails and returns error.
+ *
+ * Logical eraseblock unmap
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To unmap a logical eraseblock to a physical eraseblock, the %UBI_IOCEBUNMAP
+ * ioctl command should be used. The ioctl unmaps the logical eraseblocks,
+ * schedules corresponding physical eraseblock for erasure, and returns. Unlike
+ * the "LEB erase" command, it does not wait for the physical eraseblock being
+ * erased. Note, the side effect of this is that if an unclean reboot happens
+ * after the unmap ioctl returns, you may find the LEB mapped again to the same
+ * physical eraseblock after the UBI is run again.
+ *
+ * Check if logical eraseblock is mapped
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To check if a logical eraseblock is mapped to a physical eraseblock, the
+ * %UBI_IOCEBISMAP ioctl command should be used. It returns %0 if the LEB is
+ * not mapped, and %1 if it is mapped.
+ *
+ * Set an UBI volume property
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To set an UBI volume property the %UBI_IOCSETPROP ioctl command should be
+ * used. A pointer to a &struct ubi_set_vol_prop_req object is expected to be
+ * passed. The object describes which property should be set, and to which value
+ * it should be set.
+ */
+
+/*
+ * When a new UBI volume or UBI device is created, users may either specify the
+ * volume/device number they want to create or to let UBI automatically assign
+ * the number using these constants.
+ */
+#define UBI_VOL_NUM_AUTO (-1)
+#define UBI_DEV_NUM_AUTO (-1)
+
+/* Maximum volume name length */
+#define UBI_MAX_VOLUME_NAME 127
+
+/* ioctl commands of UBI character devices */
+
+#define UBI_IOC_MAGIC 'o'
+
+/* Create an UBI volume */
+#define UBI_IOCMKVOL _IOW(UBI_IOC_MAGIC, 0, struct ubi_mkvol_req)
+/* Remove an UBI volume */
+#define UBI_IOCRMVOL _IOW(UBI_IOC_MAGIC, 1, __s32)
+/* Re-size an UBI volume */
+#define UBI_IOCRSVOL _IOW(UBI_IOC_MAGIC, 2, struct ubi_rsvol_req)
+/* Re-name volumes */
+#define UBI_IOCRNVOL _IOW(UBI_IOC_MAGIC, 3, struct ubi_rnvol_req)
+
+/* ioctl commands of the UBI control character device */
+
+#define UBI_CTRL_IOC_MAGIC 'o'
+
+/* Attach an MTD device */
+#define UBI_IOCATT _IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)
+/* Detach an MTD device */
+#define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, __s32)
+
+/* ioctl commands of UBI volume character devices */
+
+#define UBI_VOL_IOC_MAGIC 'O'
+
+/* Start UBI volume update */
+#define UBI_IOCVOLUP _IOW(UBI_VOL_IOC_MAGIC, 0, __s64)
+/* LEB erasure command, used for debugging, disabled by default */
+#define UBI_IOCEBER _IOW(UBI_VOL_IOC_MAGIC, 1, __s32)
+/* Atomic LEB change command */
+#define UBI_IOCEBCH _IOW(UBI_VOL_IOC_MAGIC, 2, __s32)
+/* Map LEB command */
+#define UBI_IOCEBMAP _IOW(UBI_VOL_IOC_MAGIC, 3, struct ubi_map_req)
+/* Unmap LEB command */
+#define UBI_IOCEBUNMAP _IOW(UBI_VOL_IOC_MAGIC, 4, __s32)
+/* Check if LEB is mapped command */
+#define UBI_IOCEBISMAP _IOR(UBI_VOL_IOC_MAGIC, 5, __s32)
+/* Set an UBI volume property */
+#define UBI_IOCSETVOLPROP _IOW(UBI_VOL_IOC_MAGIC, 6, \
+			       struct ubi_set_vol_prop_req)
+
+/* Maximum MTD device name length supported by UBI */
+#define MAX_UBI_MTD_NAME_LEN 127
+
+/* Maximum amount of UBI volumes that can be re-named at one go */
+#define UBI_MAX_RNVOL 32
+
+/*
+ * UBI volume type constants.
+ *
+ * @UBI_DYNAMIC_VOLUME: dynamic volume
+ * @UBI_STATIC_VOLUME:  static volume
+ */
+enum {
+	UBI_DYNAMIC_VOLUME = 3,
+	UBI_STATIC_VOLUME  = 4,
+};
+
+/*
+ * UBI set volume property ioctl constants.
+ *
+ * @UBI_VOL_PROP_DIRECT_WRITE: allow (any non-zero value) or disallow (value 0)
+ *                             user to directly write and erase individual
+ *                             eraseblocks on dynamic volumes
+ */
+enum {
+	UBI_VOL_PROP_DIRECT_WRITE = 1,
+};
+
+/**
+ * struct ubi_attach_req - attach MTD device request.
+ * @ubi_num: UBI device number to create
+ * @mtd_num: MTD device number to attach
+ * @vid_hdr_offset: VID header offset (use defaults if %0)
+ * @max_beb_per1024: maximum expected number of bad PEB per 1024 PEBs
+ * @padding: reserved for future, not used, has to be zeroed
+ *
+ * This data structure is used to specify MTD device UBI has to attach and the
+ * parameters it has to use. The number which should be assigned to the new UBI
+ * device is passed in @ubi_num. UBI may automatically assign the number if
+ * @UBI_DEV_NUM_AUTO is passed. In this case, the device number is returned in
+ * @ubi_num.
+ *
+ * Most applications should pass %0 in @vid_hdr_offset to make UBI use default
+ * offset of the VID header within physical eraseblocks. The default offset is
+ * the next min. I/O unit after the EC header. For example, it will be offset
+ * 512 in case of a 512 bytes page NAND flash with no sub-page support. Or
+ * it will be 512 in case of a 2KiB page NAND flash with 4 512-byte sub-pages.
+ *
+ * But in rare cases, if this optimizes things, the VID header may be placed to
+ * a different offset. For example, the boot-loader might do things faster if
+ * the VID header sits at the end of the first 2KiB NAND page with 4 sub-pages.
+ * As the boot-loader would not normally need to read EC headers (unless it
+ * needs UBI in RW mode), it might be faster to calculate ECC. This is weird
+ * example, but it real-life example. So, in this example, @vid_hdr_offer would
+ * be 2KiB-64 bytes = 1984. Note, that this position is not even 512-bytes
+ * aligned, which is OK, as UBI is clever enough to realize this is 4th
+ * sub-page of the first page and add needed padding.
+ *
+ * The @max_beb_per1024 is the maximum amount of bad PEBs UBI expects on the
+ * UBI device per 1024 eraseblocks.  This value is often given in an other form
+ * in the NAND datasheet (min NVB i.e. minimal number of valid blocks). The
+ * maximum expected bad eraseblocks per 1024 is then:
+ *    1024 * (1 - MinNVB / MaxNVB)
+ * Which gives 20 for most NAND devices.  This limit is used in order to derive
+ * amount of eraseblock UBI reserves for handling new bad blocks. If the device
+ * has more bad eraseblocks than this limit, UBI does not reserve any physical
+ * eraseblocks for new bad eraseblocks, but attempts to use available
+ * eraseblocks (if any). The accepted range is 0-768. If 0 is given, the
+ * default kernel value of %CONFIG_MTD_UBI_BEB_LIMIT will be used.
+ */
+struct ubi_attach_req {
+	__s32 ubi_num;
+	__s32 mtd_num;
+	__s32 vid_hdr_offset;
+	__s16 max_beb_per1024;
+	__s8 padding[10];
+};
+
+/**
+ * struct ubi_mkvol_req - volume description data structure used in
+ *                        volume creation requests.
+ * @vol_id: volume number
+ * @alignment: volume alignment
+ * @bytes: volume size in bytes
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @padding1: reserved for future, not used, has to be zeroed
+ * @name_len: volume name length
+ * @padding2: reserved for future, not used, has to be zeroed
+ * @name: volume name
+ *
+ * This structure is used by user-space programs when creating new volumes. The
+ * @used_bytes field is only necessary when creating static volumes.
+ *
+ * The @alignment field specifies the required alignment of the volume logical
+ * eraseblock. This means, that the size of logical eraseblocks will be aligned
+ * to this number, i.e.,
+ *	(UBI device logical eraseblock size) mod (@alignment) = 0.
+ *
+ * To put it differently, the logical eraseblock of this volume may be slightly
+ * shortened in order to make it properly aligned. The alignment has to be
+ * multiple of the flash minimal input/output unit, or %1 to utilize the entire
+ * available space of logical eraseblocks.
+ *
+ * The @alignment field may be useful, for example, when one wants to maintain
+ * a block device on top of an UBI volume. In this case, it is desirable to fit
+ * an integer number of blocks in logical eraseblocks of this UBI volume. With
+ * alignment it is possible to update this volume using plane UBI volume image
+ * BLOBs, without caring about how to properly align them.
+ */
+struct ubi_mkvol_req {
+	__s32 vol_id;
+	__s32 alignment;
+	__s64 bytes;
+	__s8 vol_type;
+	__s8 padding1;
+	__s16 name_len;
+	__s8 padding2[4];
+	char name[UBI_MAX_VOLUME_NAME + 1];
+} __packed;
+
+/**
+ * struct ubi_rsvol_req - a data structure used in volume re-size requests.
+ * @vol_id: ID of the volume to re-size
+ * @bytes: new size of the volume in bytes
+ *
+ * Re-sizing is possible for both dynamic and static volumes. But while dynamic
+ * volumes may be re-sized arbitrarily, static volumes cannot be made to be
+ * smaller than the number of bytes they bear. To arbitrarily shrink a static
+ * volume, it must be wiped out first (by means of volume update operation with
+ * zero number of bytes).
+ */
+struct ubi_rsvol_req {
+	__s64 bytes;
+	__s32 vol_id;
+} __packed;
+
+/**
+ * struct ubi_rnvol_req - volumes re-name request.
+ * @count: count of volumes to re-name
+ * @padding1:  reserved for future, not used, has to be zeroed
+ * @vol_id: ID of the volume to re-name
+ * @name_len: name length
+ * @padding2:  reserved for future, not used, has to be zeroed
+ * @name: new volume name
+ *
+ * UBI allows to re-name up to %32 volumes at one go. The count of volumes to
+ * re-name is specified in the @count field. The ID of the volumes to re-name
+ * and the new names are specified in the @vol_id and @name fields.
+ *
+ * The UBI volume re-name operation is atomic, which means that should power cut
+ * happen, the volumes will have either old name or new name. So the possible
+ * use-cases of this command is atomic upgrade. Indeed, to upgrade, say, volumes
+ * A and B one may create temporary volumes %A1 and %B1 with the new contents,
+ * then atomically re-name A1->A and B1->B, in which case old %A and %B will
+ * be removed.
+ *
+ * If it is not desirable to remove old A and B, the re-name request has to
+ * contain 4 entries: A1->A, A->A1, B1->B, B->B1, in which case old A1 and B1
+ * become A and B, and old A and B will become A1 and B1.
+ *
+ * It is also OK to request: A1->A, A1->X, B1->B, B->Y, in which case old A1
+ * and B1 become A and B, and old A and B become X and Y.
+ *
+ * In other words, in case of re-naming into an existing volume name, the
+ * existing volume is removed, unless it is re-named as well at the same
+ * re-name request.
+ */
+struct ubi_rnvol_req {
+	__s32 count;
+	__s8 padding1[12];
+	struct {
+		__s32 vol_id;
+		__s16 name_len;
+		__s8  padding2[2];
+		char    name[UBI_MAX_VOLUME_NAME + 1];
+	} ents[UBI_MAX_RNVOL];
+} __packed;
+
+/**
+ * struct ubi_leb_change_req - a data structure used in atomic LEB change
+ *                             requests.
+ * @lnum: logical eraseblock number to change
+ * @bytes: how many bytes will be written to the logical eraseblock
+ * @dtype: pass "3" for better compatibility with old kernels
+ * @padding: reserved for future, not used, has to be zeroed
+ *
+ * The @dtype field used to inform UBI about what kind of data will be written
+ * to the LEB: long term (value 1), short term (value 2), unknown (value 3).
+ * UBI tried to pick a PEB with lower erase counter for short term data and a
+ * PEB with higher erase counter for long term data. But this was not really
+ * used because users usually do not know this and could easily mislead UBI. We
+ * removed this feature in May 2012. UBI currently just ignores the @dtype
+ * field. But for better compatibility with older kernels it is recommended to
+ * set @dtype to 3 (unknown).
+ */
+struct ubi_leb_change_req {
+	__s32 lnum;
+	__s32 bytes;
+	__s8  dtype; /* obsolete, do not use! */
+	__s8  padding[7];
+} __packed;
+
+/**
+ * struct ubi_map_req - a data structure used in map LEB requests.
+ * @dtype: pass "3" for better compatibility with old kernels
+ * @lnum: logical eraseblock number to unmap
+ * @padding: reserved for future, not used, has to be zeroed
+ */
+struct ubi_map_req {
+	__s32 lnum;
+	__s8  dtype; /* obsolete, do not use! */
+	__s8  padding[3];
+} __packed;
+
+
+/**
+ * struct ubi_set_vol_prop_req - a data structure used to set an UBI volume
+ *                               property.
+ * @property: property to set (%UBI_VOL_PROP_DIRECT_WRITE)
+ * @padding: reserved for future, not used, has to be zeroed
+ * @value: value to set
+ */
+struct ubi_set_vol_prop_req {
+	__u8  property;
+	__u8  padding[7];
+	__u64 value;
+}  __packed;
+
+#endif /* __UBI_USER_H__ */
diff --git a/libcutils/properties.c b/libcutils/properties.c
index b283658..7bc65bc1 100644
--- a/libcutils/properties.c
+++ b/libcutils/properties.c
@@ -15,7 +15,7 @@
  */
 
 #define LOG_TAG "properties"
-// #define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <stdlib.h>
 #include <string.h>
diff --git a/libion/Android.mk b/libion/Android.mk
index 6562cd3..ae61e15 100644
--- a/libion/Android.mk
+++ b/libion/Android.mk
@@ -1,22 +1,26 @@
 LOCAL_PATH := $(call my-dir)
 
 include $(CLEAR_VARS)
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH)/include \
+	$(LOCAL_PATH)/kernel-headers \
+	$(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+LOCAL_EXPORT_C_INCLUDE_DIRS := \
+	$(LOCAL_PATH)/include \
+	$(LOCAL_PATH)/kernel-headers
 LOCAL_SRC_FILES := ion.c
 LOCAL_MODULE := libion
 LOCAL_MODULE_TAGS := optional
 LOCAL_SHARED_LIBRARIES := liblog
-LOCAL_C_INCLUDES := $(LOCAL_PATH)/include $(LOCAL_PATH)/kernel-headers
-LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include $(LOCAL_PATH)/kernel-headers
-LOCAL_CFLAGS := -Werror
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH)/include \
+	$(LOCAL_PATH)/kernel-headers \
+	$(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
 LOCAL_SRC_FILES := ion.c ion_test.c
 LOCAL_MODULE := iontest
 LOCAL_MODULE_TAGS := optional tests
-LOCAL_C_INCLUDES := $(LOCAL_PATH)/include $(LOCAL_PATH)/kernel-headers
 LOCAL_SHARED_LIBRARIES := liblog
-LOCAL_CFLAGS := -Werror
 include $(BUILD_EXECUTABLE)
-
-include $(call first-makefiles-under,$(LOCAL_PATH))
diff --git a/libion/include/ion/ion.h b/libion/include/ion/ion.h
index f47793d..475bc87 100644
--- a/libion/include/ion/ion.h
+++ b/libion/include/ion/ion.h
@@ -21,24 +21,22 @@
 #ifndef __SYS_CORE_ION_H
 #define __SYS_CORE_ION_H
 
-#include <sys/types.h>
 #include <linux/ion.h>
 
 __BEGIN_DECLS
 
-struct ion_handle;
-
 int ion_open();
 int ion_close(int fd);
-int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_mask,
-              unsigned int flags, ion_user_handle_t *handle);
-int ion_alloc_fd(int fd, size_t len, size_t align, unsigned int heap_mask,
-              unsigned int flags, int *handle_fd);
+int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_id_mask,
+	      unsigned int flags, ion_user_handle_t *handle);
+int ion_alloc_fd(int fd, size_t len, size_t align, unsigned int heap_id_mask,
+		 unsigned int flags, int *handle_fd);
+int ion_invalidate_fd(int fd, int handle_fd);
 int ion_sync_fd(int fd, int handle_fd);
-int ion_free(int fd, ion_user_handle_t handle);
-int ion_map(int fd, ion_user_handle_t handle, size_t length, int prot,
+int ion_free(int fd, ion_user_handle_t *handle);
+int ion_map(int fd, ion_user_handle_t *handle, size_t length, int prot,
             int flags, off_t offset, unsigned char **ptr, int *map_fd);
-int ion_share(int fd, ion_user_handle_t handle, int *share_fd);
+int ion_share(int fd, ion_user_handle_t *handle, int *share_fd);
 int ion_import(int fd, int share_fd, ion_user_handle_t *handle);
 
 __END_DECLS
diff --git a/libion/ion.c b/libion/ion.c
index 80bdc2a..009379a 100644
--- a/libion/ion.c
+++ b/libion/ion.c
@@ -32,139 +32,127 @@
 
 int ion_open()
 {
-    int fd = open("/dev/ion", O_RDWR);
-    if (fd < 0)
-        ALOGE("open /dev/ion failed!\n");
-    return fd;
+        int fd = open("/dev/ion", O_RDWR);
+        if (fd < 0)
+                ALOGE("open /dev/ion failed!\n");
+        return fd;
 }
 
 int ion_close(int fd)
 {
-    int ret = close(fd);
-    if (ret < 0)
-        return -errno;
-    return ret;
+        return close(fd);
 }
 
 static int ion_ioctl(int fd, int req, void *arg)
 {
-    int ret = ioctl(fd, req, arg);
-    if (ret < 0) {
-        ALOGE("ioctl %x failed with code %d: %s\n", req,
-              ret, strerror(errno));
-        return -errno;
-    }
-    return ret;
+        int ret = ioctl(fd, req, arg);
+        if (ret < 0) {
+                ALOGE("ioctl %x failed with code %d: %s\n", req,
+                       ret, strerror(errno));
+                return -errno;
+        }
+        return ret;
 }
 
-int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_mask,
-              unsigned int flags, ion_user_handle_t *handle)
+int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_id_mask,
+	      unsigned int flags, ion_user_handle_t *handle)
 {
-    int ret;
-    struct ion_allocation_data data = {
-        .len = len,
-        .align = align,
-        .heap_id_mask = heap_mask,
-        .flags = flags,
-    };
-
-    if (handle == NULL)
-        return -EINVAL;
-
-    ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
-    if (ret < 0)
+        int ret;
+        struct ion_allocation_data data = {
+                .len = len,
+                .align = align,
+		.heap_id_mask = heap_id_mask,
+                .flags = flags,
+        };
+
+        ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
+        if (ret < 0)
+                return ret;
+        *handle = data.handle;
         return ret;
-    *handle = data.handle;
-    return ret;
 }
 
-int ion_free(int fd, ion_user_handle_t handle)
+int ion_free(int fd, ion_user_handle_t *handle)
 {
-    struct ion_handle_data data = {
-        .handle = handle,
-    };
-    return ion_ioctl(fd, ION_IOC_FREE, &data);
+        struct ion_handle_data data = {
+                .handle = handle,
+        };
+        return ion_ioctl(fd, ION_IOC_FREE, &data);
 }
 
-int ion_map(int fd, ion_user_handle_t handle, size_t length, int prot,
+int ion_map(int fd, ion_user_handle_t *handle, size_t length, int prot,
             int flags, off_t offset, unsigned char **ptr, int *map_fd)
 {
-    int ret;
-    struct ion_fd_data data = {
-        .handle = handle,
-    };
-
-    if (map_fd == NULL)
-        return -EINVAL;
-    if (ptr == NULL)
-        return -EINVAL;
-
-    ret = ion_ioctl(fd, ION_IOC_MAP, &data);
-    if (ret < 0)
+        struct ion_fd_data data = {
+                .handle = handle,
+        };
+
+        int ret = ion_ioctl(fd, ION_IOC_MAP, &data);
+        if (ret < 0)
+                return ret;
+        *map_fd = data.fd;
+        if (*map_fd < 0) {
+                ALOGE("map ioctl returned negative fd\n");
+                return -EINVAL;
+        }
+        *ptr = mmap(NULL, length, prot, flags, *map_fd, offset);
+        if (*ptr == MAP_FAILED) {
+                ALOGE("mmap failed: %s\n", strerror(errno));
+                return -errno;
+        }
         return ret;
-    *map_fd = data.fd;
-    if (*map_fd < 0) {
-        ALOGE("map ioctl returned negative fd\n");
-        return -EINVAL;
-    }
-    *ptr = mmap(NULL, length, prot, flags, *map_fd, offset);
-    if (*ptr == MAP_FAILED) {
-        ALOGE("mmap failed: %s\n", strerror(errno));
-        return -errno;
-    }
-    return ret;
 }
 
-int ion_share(int fd, ion_user_handle_t handle, int *share_fd)
+int ion_share(int fd, ion_user_handle_t *handle, int *share_fd)
 {
-    int map_fd;
-    int ret;
-    struct ion_fd_data data = {
-        .handle = handle,
-    };
-
-    if (share_fd == NULL)
-        return -EINVAL;
-
-    ret = ion_ioctl(fd, ION_IOC_SHARE, &data);
-    if (ret < 0)
+        int map_fd;
+        struct ion_fd_data data = {
+                .handle = handle,
+        };
+
+        int ret = ion_ioctl(fd, ION_IOC_SHARE, &data);
+        if (ret < 0)
+                return ret;
+        *share_fd = data.fd;
+        if (*share_fd < 0) {
+                ALOGE("share ioctl returned negative fd\n");
+                return -EINVAL;
+        }
         return ret;
-    *share_fd = data.fd;
-    if (*share_fd < 0) {
-        ALOGE("share ioctl returned negative fd\n");
-        return -EINVAL;
-    }
-    return ret;
 }
 
-int ion_alloc_fd(int fd, size_t len, size_t align, unsigned int heap_mask,
-                 unsigned int flags, int *handle_fd) {
-    ion_user_handle_t handle;
-    int ret;
+int ion_alloc_fd(int fd, size_t len, size_t align, unsigned int heap_id_mask,
+		 unsigned int flags, int *handle_fd) {
+	ion_user_handle_t *handle;
+	int ret;
+
+	ret = ion_alloc(fd, len, align, heap_id_mask, flags, &handle);
+	if (ret < 0)
+		return ret;
+	ret = ion_share(fd, handle, handle_fd);
+	ion_free(fd, handle);
+	return ret;
+}
 
-    ret = ion_alloc(fd, len, align, heap_mask, flags, &handle);
-    if (ret < 0)
+int ion_import(int fd, int share_fd, ion_user_handle_t *handle)
+{
+        struct ion_fd_data data = {
+                .fd = share_fd,
+        };
+
+        int ret = ion_ioctl(fd, ION_IOC_IMPORT, &data);
+        if (ret < 0)
+                return ret;
+        *handle = data.handle;
         return ret;
-    ret = ion_share(fd, handle, handle_fd);
-    ion_free(fd, handle);
-    return ret;
 }
 
-int ion_import(int fd, int share_fd, ion_user_handle_t *handle)
+int ion_invalidate_fd(int fd, int handle_fd)
 {
-    int ret;
     struct ion_fd_data data = {
-        .fd = share_fd,
+        .fd = handle_fd,
     };
-
-    if (handle == NULL)
-        return -EINVAL;
-
-    ret = ion_ioctl(fd, ION_IOC_IMPORT, &data);
-    if (ret < 0)
-        return ret;
-    *handle = data.handle;
-    return ret;
+    return ion_ioctl(fd, ION_IOC_INVALIDATE, &data);
 }
 
 int ion_sync_fd(int fd, int handle_fd)
diff --git a/libion/ion_test.c b/libion/ion_test.c
index 8872282..0caaa2a 100644
--- a/libion/ion_test.c
+++ b/libion/ion_test.c
@@ -1,19 +1,3 @@
-/*
- *   Copyright 2013 Google, Inc
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
@@ -29,6 +13,7 @@
 
 #include <ion/ion.h>
 #include <linux/ion.h>
+#include <linux/omap_ion.h>
 
 size_t len = 1024*1024, align = 0;
 int prot = PROT_READ | PROT_WRITE;
@@ -38,250 +23,256 @@ int heap_mask = 1;
 int test = -1;
 size_t stride;
 
-int _ion_alloc_test(int *fd, ion_user_handle_t *handle)
+int _ion_alloc_test(int *fd, struct ion_handle **handle)
 {
-    int ret;
+	int ret;
 
-    *fd = ion_open();
-    if (*fd < 0)
-        return *fd;
+	*fd = ion_open();
+	if (*fd < 0)
+		return *fd;
 
-    ret = ion_alloc(*fd, len, align, heap_mask, alloc_flags, handle);
+	ret = ion_alloc(*fd, len, align, heap_mask, alloc_flags, handle);
 
-    if (ret)
-        printf("%s failed: %s\n", __func__, strerror(ret));
-    return ret;
+	if (ret)
+		printf("%s failed: %s\n", __func__, strerror(ret));
+	return ret;
 }
 
 void ion_alloc_test()
 {
-    int fd, ret;
-    ion_user_handle_t handle;
+	int fd, ret;
+	struct ion_handle *handle;
 
-    if(_ion_alloc_test(&fd, &handle))
-        return;
+	if(_ion_alloc_test(&fd, &handle))
+			return;
 
-    ret = ion_free(fd, handle);
-    if (ret) {
-        printf("%s failed: %s %d\n", __func__, strerror(ret), handle);
-        return;
-    }
-    ion_close(fd);
-    printf("ion alloc test: passed\n");
+	ret = ion_free(fd, handle);
+	if (ret) {
+		printf("%s failed: %s %p\n", __func__, strerror(ret), handle);
+		return;
+	}
+	ion_close(fd);
+	printf("ion alloc test: passed\n");
 }
 
 void ion_map_test()
 {
-    int fd, map_fd, ret;
-    size_t i;
-    ion_user_handle_t handle;
-    unsigned char *ptr;
+	int fd, map_fd, ret;
+	size_t i;
+	struct ion_handle *handle;
+	unsigned char *ptr;
 
-    if(_ion_alloc_test(&fd, &handle))
-        return;
+	if(_ion_alloc_test(&fd, &handle))
+		return;
 
-    ret = ion_map(fd, handle, len, prot, map_flags, 0, &ptr, &map_fd);
-    if (ret)
-        return;
+	ret = ion_map(fd, handle, len, prot, map_flags, 0, &ptr, &map_fd);
+	if (ret)
+		return;
 
-    for (i = 0; i < len; i++) {
-        ptr[i] = (unsigned char)i;
-    }
-    for (i = 0; i < len; i++)
-        if (ptr[i] != (unsigned char)i)
-            printf("%s failed wrote %zu read %d from mapped "
-                   "memory\n", __func__, i, ptr[i]);
-    /* clean up properly */
-    ret = ion_free(fd, handle);
-    ion_close(fd);
-    munmap(ptr, len);
-    close(map_fd);
+	for (i = 0; i < len; i++) {
+		ptr[i] = (unsigned char)i;
+	}
+	for (i = 0; i < len; i++)
+		if (ptr[i] != (unsigned char)i)
+			printf("%s failed wrote %d read %d from mapped "
+			       "memory\n", __func__, i, ptr[i]);
+	/* clean up properly */
+	ret = ion_free(fd, handle);
+	ion_close(fd);
+	munmap(ptr, len);
+	close(map_fd);
 
-    _ion_alloc_test(&fd, &handle);
-    close(fd);
+	_ion_alloc_test(&fd, &handle);
+	close(fd);
 
 #if 0
-    munmap(ptr, len);
-    close(map_fd);
-    ion_close(fd);
+	munmap(ptr, len);
+	close(map_fd);
+	ion_close(fd);
 
-    _ion_alloc_test(len, align, flags, &fd, &handle);
-    close(map_fd);
-    ret = ion_map(fd, handle, len, prot, flags, 0, &ptr, &map_fd);
-    /* don't clean up */
+	_ion_alloc_test(len, align, flags, &fd, &handle);
+	close(map_fd);
+	ret = ion_map(fd, handle, len, prot, flags, 0, &ptr, &map_fd);
+	/* don't clean up */
 #endif
 }
 
 void ion_share_test()
 
 {
-    ion_user_handle_t handle;
-    int sd[2];
-    int num_fd = 1;
-    struct iovec count_vec = {
-        .iov_base = &num_fd,
-        .iov_len = sizeof num_fd,
-    };
-    char buf[CMSG_SPACE(sizeof(int))];
-    socketpair(AF_UNIX, SOCK_STREAM, 0, sd);
-    if (fork()) {
-        struct msghdr msg = {
-            .msg_control = buf,
-            .msg_controllen = sizeof buf,
-            .msg_iov = &count_vec,
-            .msg_iovlen = 1,
-        };
+	struct ion_handle *handle;
+	int sd[2];
+	int num_fd = 1;
+	struct iovec count_vec = {
+		.iov_base = &num_fd,
+		.iov_len = sizeof num_fd,
+	};
+	char buf[CMSG_SPACE(sizeof(int))];
+	socketpair(AF_UNIX, SOCK_STREAM, 0, sd);
+	if (fork()) {
+		struct msghdr msg = {
+			.msg_control = buf,
+			.msg_controllen = sizeof buf,
+			.msg_iov = &count_vec,
+			.msg_iovlen = 1,
+		};
 
-        struct cmsghdr *cmsg;
-        int fd, share_fd, ret;
-        char *ptr;
-        /* parent */
-        if(_ion_alloc_test(&fd, &handle))
-            return;
-        ret = ion_share(fd, handle, &share_fd);
-        if (ret)
-            printf("share failed %s\n", strerror(errno));
-        ptr = mmap(NULL, len, prot, map_flags, share_fd, 0);
-        if (ptr == MAP_FAILED) {
-            return;
-        }
-        strcpy(ptr, "master");
-        cmsg = CMSG_FIRSTHDR(&msg);
-        cmsg->cmsg_level = SOL_SOCKET;
-        cmsg->cmsg_type = SCM_RIGHTS;
-        cmsg->cmsg_len = CMSG_LEN(sizeof(int));
-        *(int *)CMSG_DATA(cmsg) = share_fd;
-        /* send the fd */
-        printf("master? [%10s] should be [master]\n", ptr);
-        printf("master sending msg 1\n");
-        sendmsg(sd[0], &msg, 0);
-        if (recvmsg(sd[0], &msg, 0) < 0)
-            perror("master recv msg 2");
-        printf("master? [%10s] should be [child]\n", ptr);
+		struct cmsghdr *cmsg;
+		int fd, share_fd, ret;
+		char *ptr;
+		/* parent */
+		if(_ion_alloc_test(&fd, &handle))
+			return;
+		ret = ion_share(fd, handle, &share_fd);
+		if (ret)
+			printf("share failed %s\n", strerror(errno));
+		ptr = mmap(NULL, len, prot, map_flags, share_fd, 0);
+		if (ptr == MAP_FAILED) {
+			return;
+		}
+		strcpy(ptr, "master");
+		cmsg = CMSG_FIRSTHDR(&msg);
+		cmsg->cmsg_level = SOL_SOCKET;
+		cmsg->cmsg_type = SCM_RIGHTS;
+		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+		*(int *)CMSG_DATA(cmsg) = share_fd;
+		/* send the fd */
+		printf("master? [%10s] should be [master]\n", ptr);
+		printf("master sending msg 1\n");
+		sendmsg(sd[0], &msg, 0);
+		if (recvmsg(sd[0], &msg, 0) < 0)
+			perror("master recv msg 2");
+		printf("master? [%10s] should be [child]\n", ptr);
 
-        /* send ping */
-        sendmsg(sd[0], &msg, 0);
-        printf("master->master? [%10s]\n", ptr);
-        if (recvmsg(sd[0], &msg, 0) < 0)
-            perror("master recv 1");
-    } else {
-        struct msghdr msg;
-        struct cmsghdr *cmsg;
-        char* ptr;
-        int fd, recv_fd;
-        char* child_buf[100];
-        /* child */
-        struct iovec count_vec = {
-            .iov_base = child_buf,
-            .iov_len = sizeof child_buf,
-        };
+		/* send ping */
+		sendmsg(sd[0], &msg, 0);
+		printf("master->master? [%10s]\n", ptr);
+		if (recvmsg(sd[0], &msg, 0) < 0)
+			perror("master recv 1");
+	} else {
+		struct msghdr msg;
+		struct cmsghdr *cmsg;
+		char* ptr;
+		int fd, recv_fd;
+		char* child_buf[100];
+		/* child */
+		struct iovec count_vec = {
+			.iov_base = child_buf,
+			.iov_len = sizeof child_buf,
+		};
 
-        struct msghdr child_msg = {
-            .msg_control = buf,
-            .msg_controllen = sizeof buf,
-            .msg_iov = &count_vec,
-            .msg_iovlen = 1,
-        };
+		struct msghdr child_msg = {
+			.msg_control = buf,
+			.msg_controllen = sizeof buf,
+			.msg_iov = &count_vec,
+			.msg_iovlen = 1,
+		};
 
-        if (recvmsg(sd[1], &child_msg, 0) < 0)
-            perror("child recv msg 1");
-        cmsg = CMSG_FIRSTHDR(&child_msg);
-        if (cmsg == NULL) {
-            printf("no cmsg rcvd in child");
-            return;
-        }
-        recv_fd = *(int*)CMSG_DATA(cmsg);
-        if (recv_fd < 0) {
-            printf("could not get recv_fd from socket");
-            return;
-        }
-        printf("child %d\n", recv_fd);
-        fd = ion_open();
-        ptr = mmap(NULL, len, prot, map_flags, recv_fd, 0);
-        if (ptr == MAP_FAILED) {
-            return;
-        }
-        printf("child? [%10s] should be [master]\n", ptr);
-        strcpy(ptr, "child");
-        printf("child sending msg 2\n");
-        sendmsg(sd[1], &child_msg, 0);
-    }
+		if (recvmsg(sd[1], &child_msg, 0) < 0)
+			perror("child recv msg 1");
+		cmsg = CMSG_FIRSTHDR(&child_msg);
+		if (cmsg == NULL) {
+			printf("no cmsg rcvd in child");
+			return;
+		}
+		recv_fd = *(int*)CMSG_DATA(cmsg);
+		if (recv_fd < 0) {
+			printf("could not get recv_fd from socket");
+			return;
+		}
+		printf("child %d\n", recv_fd);
+		fd = ion_open();
+		ptr = mmap(NULL, len, prot, map_flags, recv_fd, 0);
+		if (ptr == MAP_FAILED) {
+			return;
+		}
+		printf("child? [%10s] should be [master]\n", ptr);
+		strcpy(ptr, "child");
+		printf("child sending msg 2\n");
+		sendmsg(sd[1], &child_msg, 0);
+	}
 }
 
 int main(int argc, char* argv[]) {
-    int c;
-    enum tests {
-        ALLOC_TEST = 0, MAP_TEST, SHARE_TEST,
-    };
+	int c;
+	enum tests {
+		ALLOC_TEST = 0, MAP_TEST, SHARE_TEST,
+	};
 
-    while (1) {
-        static struct option opts[] = {
-            {"alloc", no_argument, 0, 'a'},
-            {"alloc_flags", required_argument, 0, 'f'},
-            {"heap_mask", required_argument, 0, 'h'},
-            {"map", no_argument, 0, 'm'},
-            {"share", no_argument, 0, 's'},
-            {"len", required_argument, 0, 'l'},
-            {"align", required_argument, 0, 'g'},
-            {"map_flags", required_argument, 0, 'z'},
-            {"prot", required_argument, 0, 'p'},
-        };
-        int i = 0;
-        c = getopt_long(argc, argv, "af:h:l:mr:st", opts, &i);
-        if (c == -1)
-            break;
+	while (1) {
+		static struct option opts[] = {
+			{"alloc", no_argument, 0, 'a'},
+			{"alloc_flags", required_argument, 0, 'f'},
+			{"heap_mask", required_argument, 0, 'h'},
+			{"map", no_argument, 0, 'm'},
+			{"share", no_argument, 0, 's'},
+			{"len", required_argument, 0, 'l'},
+			{"align", required_argument, 0, 'g'},
+			{"map_flags", required_argument, 0, 'z'},
+			{"prot", required_argument, 0, 'p'},
+		};
+		int i = 0;
+		c = getopt_long(argc, argv, "af:h:l:mr:st", opts, &i);
+		if (c == -1)
+			break;
 
-        switch (c) {
-        case 'l':
-            len = atol(optarg);
-            break;
-        case 'g':
-            align = atol(optarg);
-            break;
-        case 'z':
-            map_flags = 0;
-            map_flags |= strstr(optarg, "PROT_EXEC") ? PROT_EXEC : 0;
-            map_flags |= strstr(optarg, "PROT_READ") ? PROT_READ: 0;
-            map_flags |= strstr(optarg, "PROT_WRITE") ? PROT_WRITE: 0;
-            map_flags |= strstr(optarg, "PROT_NONE") ? PROT_NONE: 0;
-            break;
-        case 'p':
-            prot = 0;
-            prot |= strstr(optarg, "MAP_PRIVATE") ? MAP_PRIVATE : 0;
-            prot |= strstr(optarg, "MAP_SHARED") ? MAP_PRIVATE : 0;
-            break;
-        case 'f':
-            alloc_flags = atol(optarg);
-            break;
-        case 'h':
-            heap_mask = atol(optarg);
-            break;
-        case 'a':
-            test = ALLOC_TEST;
-            break;
-        case 'm':
-            test = MAP_TEST;
-            break;
-        case 's':
-            test = SHARE_TEST;
-            break;
-        }
-    }
-    printf("test %d, len %zu, align %zu, map_flags %d, prot %d, heap_mask %d,"
-           " alloc_flags %d\n", test, len, align, map_flags, prot,
-           heap_mask, alloc_flags);
-    switch (test) {
-        case ALLOC_TEST:
-            ion_alloc_test();
-            break;
-        case MAP_TEST:
-            ion_map_test();
-            break;
-        case SHARE_TEST:
-            ion_share_test();
-            break;
-        default:
-            printf("must specify a test (alloc, map, share)\n");
-    }
-    return 0;
+		switch (c) {
+		case 'l':
+			len = atol(optarg);
+			break;
+		case 'g':
+			align = atol(optarg);
+			break;
+		case 'z':
+			map_flags = 0;
+			map_flags |= strstr(optarg, "PROT_EXEC") ?
+				PROT_EXEC : 0;
+			map_flags |= strstr(optarg, "PROT_READ") ?
+				PROT_READ: 0;
+			map_flags |= strstr(optarg, "PROT_WRITE") ?
+				PROT_WRITE: 0;
+			map_flags |= strstr(optarg, "PROT_NONE") ?
+				PROT_NONE: 0;
+			break;
+		case 'p':
+			prot = 0;
+			prot |= strstr(optarg, "MAP_PRIVATE") ?
+				MAP_PRIVATE	 : 0;
+			prot |= strstr(optarg, "MAP_SHARED") ?
+				MAP_PRIVATE	 : 0;
+			break;
+		case 'f':
+			alloc_flags = atol(optarg);
+			break;
+		case 'h':
+			heap_mask = atol(optarg);
+			break;
+		case 'a':
+			test = ALLOC_TEST;
+			break;
+		case 'm':
+			test = MAP_TEST;
+			break;
+		case 's':
+			test = SHARE_TEST;
+			break;
+		}
+	}
+	printf("test %d, len %u, align %u, map_flags %d, prot %d, heap_mask %d,"
+	       " alloc_flags %d\n", test, len, align, map_flags, prot,
+	       heap_mask, alloc_flags);
+	switch (test) {
+		case ALLOC_TEST:
+			ion_alloc_test();
+			break;
+		case MAP_TEST:
+			ion_map_test();
+			break;
+		case SHARE_TEST:
+			ion_share_test();
+			break;
+		default:
+			printf("must specify a test (alloc, map, share)\n");
+	}
+	return 0;
 }
diff --git a/libion/kernel-headers/linux/omap_ion.h b/libion/kernel-headers/linux/omap_ion.h
new file mode 100644
index 0000000..65af914
--- /dev/null
+++ b/libion/kernel-headers/linux/omap_ion.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ***   To edit the content of this header, modify the corresponding
+ ***   source file (e.g. under external/kernel-headers/original/) then
+ ***   run bionic/libc/kernel/tools/update_all.py
+ ***
+ ***   Any manual change here will be lost the next time this script will
+ ***   be run. You've been warned!
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+#ifndef _LINUX_OMAP_ION_H
+#define _LINUX_OMAP_ION_H
+#include <linux/types.h>
+struct omap_ion_tiler_alloc_data {
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+ size_t w;
+ size_t h;
+ int fmt;
+ unsigned int flags;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+ struct ion_handle *handle;
+ size_t stride;
+ size_t offset;
+};
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+enum {
+ OMAP_ION_HEAP_TYPE_TILER = ION_HEAP_TYPE_CUSTOM + 1,
+};
+#define OMAP_ION_HEAP_TILER_MASK (1 << OMAP_ION_HEAP_TYPE_TILER)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+enum {
+ OMAP_ION_TILER_ALLOC,
+};
+enum {
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+ TILER_PIXEL_FMT_MIN = 0,
+ TILER_PIXEL_FMT_8BIT = 0,
+ TILER_PIXEL_FMT_16BIT = 1,
+ TILER_PIXEL_FMT_32BIT = 2,
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+ TILER_PIXEL_FMT_PAGE = 3,
+ TILER_PIXEL_FMT_MAX = 3
+};
+enum {
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+ OMAP_ION_HEAP_LARGE_SURFACES,
+ OMAP_ION_HEAP_TILER,
+ OMAP_ION_HEAP_SECURE_INPUT,
+};
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#endif
1.9.1

